---
layout: post
tag: [岐大祭2018]
---

この記事は、岐大祭に向けてアドベントカレンダー的な記事を書く企画の 1 日目です。

この企画はもともと、各人の成果物に加え、共同制作としてそれら成果物を作る過程で得られた技術的な知見をまとめた本を配ろうというものでした。
結局はこのように、本ではなく記事として公開する形になりましたが、自分は本のためにコードを書いたりしていたのでその話をしたいと思います。

## Re:VIEW と pandoc

一般的に、電子書籍つまり EPUB や PDF の生成には [InDesign](https://www.adobe.com/jp/products/indesign.html) が使われるようですが、 OSS だと [pandoc](https://pandoc.org) や [Re:VIEW](https://github.com/kmuto/review) といった候補があります。
pandoc はメジャーな形式をほとんど押さえている文書コンバーターであり、 Markdown から EPUB や PDF を生成したり出来ます。
Re:VIEW も EPUB や PDF を生成でき [技術書典](https://techbookfest.org/) などでも使われているようですが、入力ファイルが独自の形式で少しとっつきにくく感じました。

どちらを使おうかは結構考えたのですが、 自分が普段から pandoc を使っているというのと、 共同制作なので Markdown で書けたほうが楽かと思い pandoc を使うことにしました。
pandoc にもファイルを繋いだり目次を作ってくれる機能があったとか、 textlint が使いたかったとか、ドキュメントの充実具合とかも選定の理由だった気がします。

## TeX と Chrome と puppeteer

これは Re:VIEW でも同じですが、そのまま pdf を吐こうとすると TeX のスタイルファイルを書く必要があります。
LaTeX の環境構築はそれなりに大変ですし、 EPUB 版とデザインを揃えたかったこともあり HTML を経由して PDF を生成しようと考えました。
具体的には Chrome の印刷機能をコマンドラインから呼び出します。
だいたい以下のような流れでした。

```sh
sed -e '1i---' -e '$a---' book.yml > yaml.md
pandoc -o book.html --toc -N -c style.css -s yaml.md chap01.md chap02.md
google-chrome --headless --disable-gpu --print-to-pdf=book.pdf book.html
```

最初の `sed` で _book.yml_ を [yaml metadata block](http://pandoc.org/MANUAL.html#extension-yaml_metadata_block) だけの Markdown に変換しています。
`--disable-gpu` は `--headless` を付けて Chrome を起動した際の描画のバグを回避するためだった気がします。
_style.css_ は PDF の四隅の余白を消すために書いています。

```css
@page {
  margin: 0;
}
```

[@page](https://developer.mozilla.org/ja/docs/Web/CSS/@page) で変更できるプロパティは限定的ですが、 [@media print](https://developer.mozilla.org/ja/docs/Web/CSS/@media#Examples) を使うと印刷時にのみ有効なスタイルを定義したりもできます。

といっても結局はヘッダーが入ってしまったので [puppeteer](https://github.com/GoogleChrome/puppeteer) を使いました。
これは [公式のサンプルコード](https://github.com/GoogleChrome/puppeteer#usage) もあったので結構簡単でした。
以下は次節の Docker コンテナ環境で動くように書いたモジュールです。

```js
const puppeteer = require("puppeteer-core");

module.exports = async (html, pdf, papersize) => {
  const browser = await puppeteer.launch({
    executablePath: "/usr/bin/chromium-browser",
    args: ["--disable-dev-shm-usage"]
  });

  const page = await browser.newPage();
  await page.goto(`file:${__dirname}/${html}`);
  await page.pdf({
    path: pdf,
    printBackground: true,
    format: papersize
  });

  await browser.close();
};
```

`html` で PDF にしたい HTML ファイルを、 `pdf` で PDF のファイル名を、 `papersize` で PDF の用紙サイズを指定する感じです。
`--disable-dev-shm-usage` は [コンテナのメモリの関係で必要らしい](https://github.com/GoogleChrome/puppeteer/blob/master/docs/troubleshooting.md#tips) です。

## Docker と Alpine Linux

puppeteer のおかげで TeX の環境構築は不要になりましたが、 pandoc と Node.js が必要なので [Alpine Linux](https://alpinelinux.org/) ベースの Dockerfile も作ってみました。
chromium も edge にならあるのでついでに入れています。
Dockerfile はこのあたりを参考に作りました。

- <https://github.com/jgm/pandoc/blob/master/INSTALL.md#compiling-from-source>
- <https://github.com/k1LoW/docker-alpine-pandoc-ja>
- <https://github.com/GoogleChrome/puppeteer/blob/master/docs/troubleshooting.md#running-on-alpine>
- <https://github.com/Zenika/alpine-chrome>

完成したのが [こちら](https://github.com/ahuglajbclajep/dockerfiles/blob/master/alpine-node-chromium-pandoc/Dockerfile) 。
Alpine は `apk add` 時に `--virtual` もしくは `-t` で名前を付けておくと、 `apk del` 時にその名前でパッケージをまとめて消せるので便利です。
ash だったり（BusyBox なので）コマンドのオプションがなかったり glibc でなく musl を使ってたりで嵌ることはありますが、全体的にはコンパクトで使いやすいと思います。

## Noto と CSS

- Alpine には当然日本語フォントがないので豆腐になる
- フォントの種類の軽い説明と noto フォントの話
- noto フォントの配布形態
- いろいろ試行錯誤をやった結果、こんな構成でうまくいきました

## fs/promises と promisify

- pandoc に渡すオプションも複雑になってきて、シェルスクリプトでは厳しくなってきた
- 特に epub と pdf では必要なパラメーターも違う点など
- puppeteer の時点で Node.js を使ってたので Node.js でビルドスクリプトを書くことにした
- fs-extra と fs/promises
- child_process.exec と promisify

## まとめ

- ここまでは来たけれど EPUB のメタデータの扱いが難しい
- PDF も CSS でいろいろ調声したが、結局微妙にずれたりしてこういう OSS がありそうでない理由を悟った
- とは言っても、いろいろ気になってた技術を実際に試せたのは有意義だったし楽しかった
- 余談だが別件で PDF 構造解説を読んだのでまたチャレンジしてみたい
- まあでも Re:VIEW のほうがいいかも
