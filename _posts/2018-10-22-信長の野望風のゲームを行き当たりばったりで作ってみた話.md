---
layout: post
tag: [岐大祭2018]
---

この記事は、岐大祭に向けてアドベントカレンダー的な記事を書く企画の ３日目です。

私が作ったのは信長の野望風のゲームを東方のキャラを使用して同人ゲームとして仕上げてみたものです。
このゲームは、私がUnityのUI周りの勉強がてらに作成されたものなのでとてもごちゃごちゃしています笑

そんな中でも少しでも参考・転用できる技術があれば、という記事になります。

## 信長の野望
`信長の野望`とは[コーエーテクモゲームス](https://www.gamecity.ne.jp/)の人気シリーズである歴史シミュレーションである。


## UI
基本的にこのゲームではあらかじめほとんどのUIを作成しておき、必要のないときは`gameObject.SetActive(false)`で画面に表示されないようにしている。

#### Buttonクリック時のスクリプト呼び出しを共通化する
（１）こういったButtonの多くなるゲームでは[スクリプト呼び出しを共通化](https://fantastic-works.com/archives/148)することによってScriptの管理を
簡潔にすることができる。

（２）各SceneにUIの処理を行う[シングルトン](http://hiyotama.hatenablog.com/entry/2015/06/26/090000)にButtonを押した際に呼びたいメソッドを
記述しておき、UnityのInspecter上からそのメソッドをクリックイベントに登録する。
この際、Sceneを跨ぐシングルトンを参照したい場合は、
```
Button
　↓参照
そのSceneのUIを統括するシングルトン
　↓参照
全てのSceneで使用されるシングルトン（今回の場合、BGMControllerなど）
```
の手順で参照しないと、シングルトンの仕様上NullExceptionを起こすので注意する。


#### Layout
UIのLayoutは主に`Vertical Layout Group(以下、VLG)`と`Horizontal Layout Group(以下、HLG)`と`Content Size Fitter(以下、CSF)`を使用している。
VLGとHLGは子オブジェクトの配置を良い感じにしてくれるConponentで、CSFはVLGやHLGで配置した子オブジェクトの大きさに応じて親オブジェクトの大きさを
良い感じに調節してくれるConponentである。

使用方法は簡単で、並べたい方向に応じてVLGまたはHLGをアタッチしてUI群を整頓し、そのあとCSFをアタッチして有効にすることで
UIを良い感じに簡単に配置することが出来る。


#### Image
UIのImageをスクリプトから設定したいときは、Resourceフォルダにあらかじめ保存しておき、
```
image.AddComponent<Image>().sprite = Resources.Load<Sprite>("ImageName");
```
で呼び出すことが出来る。


#### Scroll View
UIの中でも[Scroll View](http://tsubakit1.hateblo.jp/entry/2014/12/18/040252)は少し複雑で、
```
ScrollView
├── Viewport  <=  実際に表示されるViewの大きさ(Maskになっている)
│   └── Content  <=  実際に表示したいGameObjectを入れる親オブジェクト
├── Scrollbar Horizontal
│   └── Sliding Area
│       └── Handle
└── Scrollbar Vertical
    └── Sliding Area
        └── Handle
```
という構成になっている。この`Content`にVLGやHLG、CSFをアタッチすることで、中身を自動的に整頓・整形してくれるようになる。

また、`Viewport`の大きさを画面サイズに、`Content`のサイズを画面サイズの二倍にして、`Content`のImageのConponentを削除し、
`Content`に子オブジェクトを設定すると画面内を移動するUIが作れる。


#### スクリーン座標とワールド座標
[ワールド座標からスクリーン座標を取得](http://tsubakit1.hateblo.jp/entry/2016/03/01/020510)したい場合、
```
UI.position = RectTransformUtility.WorldToScreenPoint (Camera.main, target.transform);
```
で取得することが出来る。今回の場合`カーソルがtargetにhitしている場合その詳細をUI上に表示する`という風に使用している。



[スクリーン座標からワールド座標を取得](http://tsubakit1.hateblo.jp/entry/2016/03/01/020510)したい場合、
```
        Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
        RaycastHit hit;
        if (Physics.Raycast(ray, out hit, Mathf.Infinity))
        {
            //RaycastがGameObjectにhitした場合の処理
            //hit.transform.gameObjectでhitしたGameObjectを取得できる
        }
```
で取得できる。ただし、一番最初にhitしたGameObjectしか取得できないため複数のGameObjectを取得したい場合は、
```
        PointerEventData pointer = new PointerEventData(EventSystem.current);
        pointer.position = Input.mousePosition;
        
        //カーソルの位置にあるUIをすべて返す
        List<RaycastResult> results = new List<RaycastResult>();
        EventSystem.current.RaycastAll(pointer, results);
        
        //カーソルの位置にあるGameObjectをすべて返す
        List<RaycastHit> raycastHits = Physics.RaycastAll(ray).ToList();
```
を使用している。
