---
layout: post
tag: [岐大祭2018]
---

この記事は、岐大祭に向けてアドベントカレンダー的な記事を書く企画の ３日目です。

私が作ったのは信長の野望風のゲームを東方のキャラを使用して同人ゲームとして仕上げてみたものですが、私がUnityのUI周りの勉強がてらに作成されたものなのでとてもごちゃごちゃしています笑

そんな中でも少しでも参考・転用できる技術があれば、という記事になります。

# 信長の野望
`信長の野望`とは[コーエーテクモゲームス](https://www.gamecity.ne.jp/)の人気シリーズである歴史シミュレーションゲームである。

# UI
このゲームでは、基本的にあらかじめUIを作成しておき、必要のないときは`gameObject.SetActive(false)`で画面に表示されないようにしている。

### Buttonクリック時のスクリプト呼び出しを共通化する
（１）こういったButtonの多くなるゲームでは[スクリプト呼び出しを共通化](https://fantastic-works.com/archives/148)することによってScriptの管理を簡潔にすることができる。

（２）各SceneにUIの処理を行う[シングルトン](http://hiyotama.hatenablog.com/entry/2015/06/26/090000)にButtonを押した際に呼びたいメソッドを記述しておき、UnityのInspecter上からそのメソッドをクリックイベントに登録する。
この際、Sceneを跨ぐシングルトンを参照したい場合は、
```
Button
　↓参照
そのSceneのUIを統括するシングルトン
　↓参照
全てのSceneで使用されるシングルトン（今回の場合、BGMControllerなど）
```
の手順で参照しないと、シングルトンの仕様上NullExceptionを起こすので注意する。

### Layout
UIのLayoutは主に`Vertical Layout Group(以下、VLG)`と`Horizontal Layout Group(以下、HLG)`と`Content Size Fitter(以下、CSF)`を使用している。VLGとHLGは子オブジェクトの配置を良い感じにしてくれるConponentで、CSFはVLGやHLGで配置した子オブジェクトの大きさに応じて親オブジェクトの大きさを良い感じに調節してくれるConponentである。

使用方法は簡単で、並べたい方向に応じてVLGまたはHLGをアタッチしてUI群を整頓し、そのあとCSFをアタッチして有効にすることでUIを良い感じに簡単に配置することが出来る。


### Image
UIのImageをスクリプトから設定したいときは、Resourceフォルダにあらかじめ保存しておき、
```
image.AddComponent<Image>().sprite = Resources.Load<Sprite>("ImageName");
```
で呼び出すことが出来る。

### Scroll View
UIの中でも[Scroll View](http://tsubakit1.hateblo.jp/entry/2014/12/18/040252)は少し複雑で、
```
ScrollView
├── Viewport  <=  実際に表示されるViewの大きさ(Maskになっている)
│   └── Content  <=  実際に表示したいGameObjectを入れる親オブジェクト
├── Scrollbar Horizontal
│   └── Sliding Area
│       └── Handle
└── Scrollbar Vertical
    └── Sliding Area
        └── Handle
```
という構成になっている。この`Content`にVLGやHLG、CSFをアタッチすることで、中身を自動的に整頓・整形してくれるようになる。

また、`Viewport`の大きさを画面サイズに、`Content`のサイズを画面サイズの二倍にして、`Content`のImageのConponentを削除し、`Content`に子オブジェクトを設定すると画面内を移動するUIが作れる。

### スクリーン座標とワールド座標
[ワールド座標からスクリーン座標を取得](http://tsubakit1.hateblo.jp/entry/2016/03/01/020510)したい場合、
```
UI.position = RectTransformUtility.WorldToScreenPoint (Camera.main, target.transform);
```
で取得することが出来る。今回の場合`カーソルがtargetにhitしている場合その詳細をUI上に表示する`という風に使用している。

[スクリーン座標からワールド座標を取得](http://tsubakit1.hateblo.jp/entry/2016/03/01/020510)したい場合、
```
Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
RaycastHit hit;
if (Physics.Raycast(ray, out hit, Mathf.Infinity))
{
    //RaycastがGameObjectにhitした場合の処理
    //hit.transform.gameObjectでhitしたGameObjectを取得できる
}
```
で取得できる。ただし、一番最初にhitしたGameObjectしか取得できないため複数のGameObjectを取得したい場合は、
```
PointerEventData pointer = new PointerEventData(EventSystem.current);
pointer.position = Input.mousePosition;
     
//カーソルの位置にあるUIをすべて返す
List<RaycastResult> results = new List<RaycastResult>();
EventSystem.current.RaycastAll(pointer, results);
        
//カーソルの位置にあるGameObjectをすべて返す
List<RaycastHit> raycastHits = Physics.RaycastAll(ray).ToList();
```
を使用している。

# Terrain
このゲームではTerrainを[スクリプト上から設定](http://nirasan.hatenablog.com/entry/2014/08/27/160901)し、マップをゲームごとにランダム生成している。基本的に行っていることは`川の生成`,`山の生成`,`海岸線の生成`,`森の生成`,`橋の生成`,`拠点の生成`,`Textureの設定`である。

### Height Map
`Height Map`はTerrainの高さを設定する値であり、0.0~1.0の値を持つ`float[,]型の二次元配列`である。この値を設定することで`川の生成`,`山の生成`,`海岸線の生成`を行っている。設定した二次元配列は`Terrain.TerrainData.SetHeights(int x, int y, float[,] heights)`でTerrainにセットすることが出来る。`x`と`y`はオフセットである。

### Alpha Map
`Alpha Map`はTerrainのTextureの濃度を設定する値であり、0.0~1.0の値を持つ`float[,,]型の三次元配列`である。三次元目はあらかじめInspecter上で設定されているTexture番号を`int型`で指定する。設定した三次元配列は、`Terrain.TerrainData.SetAlphamaps(int x, int y, float[,,] map)`でTerrainにセットすることが出来る。`x`と`y`はオフセットである。

また、`Alpha Map`はTextureが加算されてしまうので不要な箇所の値は0にしておく必要がある。

# マスターデータのインポート
このゲームではキャラクターの基本情報やアイテムの基本情報などを[Excelからインポート](http://nirasan.hatenablog.com/entry/2014/08/27/160901)している。
こうすることで多くのデータをひとつのExcelファイルに整理出来て便利だと思う。

# セーブ機能
このゲームでは[Json形式を用いたセーブ方法](http://kan-kikuchi.hatenablog.com/entry/Json_SaveData)を採用している。簡単に説明すると、
```
public void Save()
{
    //このクラスにセーブしたい要素を一度保存する
    _jsonText = JsonUtility.ToJson(this);  <=  このクラスをJson化する
    File.WriteAllText(GetSaveFilePath(), _jsonText);  //GetSaveFilePathで保存するPathを設定している
}

public void Load()
{
    JsonUtility.FromJsonOverwrite(GetJson(), this);  <=  GetJsonで保存されているJsonを取得し、このクラスの持つフィールドに上書きする
    //その後、各GameObjectにロードしたJsonを反映する    
}
```
ということを行っている。

# NavMesh
このゲームではUnitの移動に[NavMeshAgent](http://tsubakit1.hateblo.jp/entry/20120127/1327591104)を使用している。`NavMeshAgent`はNavMesh上を自動で移動してくれる便利なConponentだが、マップを毎回ランダムに生成するため`NavMeshの静的Bake`をすることが出来ず、下記のように[動的Bake](https://gametukurikata.com/navigation/runtimenavigationbake)を行うこととなった。
```
    NavMeshData = NavMeshSurface.BuildNavMesh();  <=  空のNavMeshDataを作成する
    NavMeshSurface.UpdateNavMesh(NavMeshData));  <=  こうすると非同期でBakeをすることが出来る！すごい！
```
`NavMeshSurface`は[NavMeshComponents](https://github.com/Unity-Technologies/NavMeshComponents)という追加アセットの中にある。

また、動的Bakeを非同期で行うことで、NowLoading画面を表示することを可能にしている。(このBakeがとても長い・・・。)
